# VS Code MCP Diagnostics Extension - Cursor Rules

## 🎯 Project Overview
You are working on the **MCP Diagnostics Extension** for VS Code that monitors diagnostic information (errors, warnings) from the Problems panel and exposes them via Model Context Protocol (MCP) for AI agent consumption.

## 🚨 Critical Workflow Requirements

### 1. Dependency Management (CRITICAL)
```typescript
// ❌ NEVER add external dependencies without careful consideration
// ✅ ALWAYS prefer native implementations

// Example: Use custom debounce instead of lodash
function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(
  func: F,
  wait: number
): (...args: Parameters<F>) => void {
  let timeout: NodeJS.Timeout | undefined;
  return (...args: Parameters<F>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = undefined;
      func(...args);
    }, wait);
  };
}
```

**Why**: External dependencies can cause packaging issues due to `.vscodeignore` excluding `node_modules/`

### 2. Mandatory Testing Protocol
```bash
# BEFORE every commit/change, run:
npm run lint           # Must pass with 0 errors
npm run compile        # Must compile successfully
npm test              # All 334+ tests must pass
npm run package       # Must package without errors
```

### 3. Bug Investigation Checklist
When investigating issues, ALWAYS:
1. ✅ Check Extension Host Output logs first
2. ✅ Test in both Extension Development Host (F5) AND packaged installation
3. ✅ Compare behavior between VS Code and Cursor
4. ✅ Document exact error messages and stack traces
5. ✅ Identify environment differences

### 4. Version Management
```json
// Semantic Versioning Rules
{
  "PATCH": "Bug fixes (1.2.0 → 1.2.1)",
  "MINOR": "New features (1.2.1 → 1.3.0)",
  "MAJOR": "Breaking changes (1.3.0 → 2.0.0)"
}
```

## 🚀 **COMPLETE RELEASE MANAGEMENT WORKFLOW**

### **Phase 1: Pre-Release Validation**
```bash
# 1. Ensure all quality gates pass
npm run ci:check                    # All tests, linting, compilation
npm run validate-package           # Dependency validation
npm run package                    # Test packaging

# 2. Verify critical functionality
# - Test in Extension Development Host (F5)
# - Test packaged extension installation
# - Verify MCP tools work correctly
# - Check all commands and UI elements
```

### **Phase 2: Release Preparation**
```bash
# 1. Stage all changes
git add .

# 2. Create conventional commit
git commit -m "fix: resolve critical dependency packaging issue preventing extension activation"
# OR
git commit -m "feat: add new MCP tool for workspace summaries"
# OR
git commit -m "docs: update API documentation with examples"

# 3. Use standard-version for automated release management
npm run release:patch              # For bug fixes (1.2.2 → 1.2.3)
npm run release:minor              # For new features (1.2.3 → 1.3.0)
npm run release:major              # For breaking changes (1.3.0 → 2.0.0)
```

### **Phase 3: Release Execution**
```bash
# 1. Push changes and tags to remote
git push --follow-tags origin master

# 2. Package extension for distribution
npm run package

# 3. Create GitHub release with VSIX attachment
gh release create v1.2.3 mcp-diagnostics-extension-1.2.3.vsix \
  --title "v1.2.3 - Critical Dependency Fix" \
  --notes-from-tag \
  --latest

# 4. Validate package contents
npm run validate-package           # Ensure dependencies included
```

### **Phase 4: Post-Release Verification**
```bash
# 1. Verify GitHub release created successfully
# 2. Test VSIX installation from release
# 3. Confirm extension works in clean environment
# 4. Update project documentation if needed
# 5. Monitor for any immediate issues
```

### **Phase 5: Marketplace Publishing (Optional)**
```bash
# For marketplace releases
npm run publish                    # Publishes to VS Code Marketplace
# OR
vsce publish                       # Direct marketplace publishing
```

## 🔧 **Release Workflow Scripts**

### **Required package.json Scripts**
```json
{
  "scripts": {
    "release:patch": "standard-version --release-as patch",
    "release:minor": "standard-version --release-as minor",
    "release:major": "standard-version --release-as major",
    "ci:check": "npm run lint && npm run compile && npm test",
    "validate-package": "bash scripts/validate-package.sh",
    "package": "vsce package",
    "publish": "vsce publish"
  }
}
```

### **Standard-Version Configuration (.versionrc.json)**
```json
{
  "types": [
    {"type": "feat", "section": "Features"},
    {"type": "fix", "section": "Bug Fixes"},
    {"type": "docs", "section": "Documentation"},
    {"type": "style", "section": "Styles", "hidden": true},
    {"type": "refactor", "section": "Code Refactoring", "hidden": true},
    {"type": "perf", "section": "Performance Improvements"},
    {"type": "test", "section": "Tests", "hidden": true},
    {"type": "build", "section": "Build System", "hidden": true},
    {"type": "ci", "section": "CI", "hidden": true}
  ],
  "commitUrlFormat": "https://github.com/newbpydev/mcp-diagnostics-extension/commit/{{hash}}",
  "compareUrlFormat": "https://github.com/newbpydev/mcp-diagnostics-extension/compare/{{previousTag}}...{{currentTag}}",
  "scripts": {
    "postchangelog": "npm run format -- CHANGELOG.md"
  }
}
```

## 🚨 **Critical Release Checklist**

### **Before Every Release**
- [ ] All 334+ tests passing
- [ ] Zero linting errors
- [ ] Successful compilation
- [ ] Package validation passes
- [ ] Extension works in both F5 and packaged environments
- [ ] All dependencies correctly included in package
- [ ] Version number follows semantic versioning
- [ ] Conventional commit message format used
- [ ] CHANGELOG.md updated automatically

### **During Release**
- [ ] Standard-version executed successfully
- [ ] Git tags pushed to remote
- [ ] GitHub release created with VSIX attachment
- [ ] Package contents validated
- [ ] Release notes generated from commits

### **After Release**
- [ ] GitHub release verified
- [ ] VSIX installation tested
- [ ] Extension functionality confirmed
- [ ] Documentation updated if needed
- [ ] Team notified of release

## 🔍 **Troubleshooting Release Issues**

### **Common Problems & Solutions**

#### **1. Dependency Packaging Issues**
```bash
# Problem: "Cannot find module 'zod'" in packaged extension
# Solution: Check .vscodeignore includes runtime dependencies
!node_modules/zod/**
!node_modules/@modelcontextprotocol/**

# Validate with:
npm run validate-package
unzip -l *.vsix | grep -E "(zod|modelcontextprotocol)"
```

#### **2. Standard-Version Failures**
```bash
# Problem: standard-version fails to create release
# Solution: Ensure conventional commits and clean git state
git status                         # Check for uncommitted changes
git log --oneline -5              # Verify commit format
npm run release:patch -- --dry-run # Test release without changes
```

#### **3. GitHub Release Issues**
```bash
# Problem: gh release create fails
# Solution: Check authentication and repository access
gh auth status                     # Verify GitHub CLI authentication
gh repo view                       # Confirm repository access
```

#### **4. Package Validation Failures**
```bash
# Problem: validate-package script fails
# Solution: Check package contents and dependencies
npm run package                    # Recreate package
unzip -l *.vsix | head -20        # Inspect package contents
npm ls                             # Check dependency tree
```

## 📋 Code Quality Standards

### TypeScript Configuration
- Use strict TypeScript settings
- No `any` types allowed (use `unknown` if needed)
- Proper JSDoc documentation for all public APIs
- Type-safe event handling

### Error Handling Pattern
```typescript
// ✅ Always use this pattern for external API calls
try {
  const result = await externalApiCall();
  return result;
} catch (error) {
  console.error('Specific operation failed:', error);
  // Graceful degradation or re-throw with context
  throw new Error(`Failed to perform operation: ${error.message}`);
}
```

### VS Code API Best Practices
```typescript
// ✅ Dependency injection for testability
export class DiagnosticsWatcher {
  constructor(private vscodeApi: IVsCodeApi) {}
}

// ✅ Proper disposal management
export function activate(context: vscode.ExtensionContext) {
  const watcher = new DiagnosticsWatcher(vscode);
  context.subscriptions.push(watcher);
}

// ❌ Never call global getDiagnostics() without URI
// ✅ Always use URI-specific calls
event.uris.forEach(uri => {
  const diagnostics = vscode.languages.getDiagnostics(uri);
});
```

## 🔧 MCP Integration Standards

### Request Handler Pattern
```typescript
// ✅ Use schema-based handlers (MCP SDK v1.12.1+)
this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
  // Implementation
});

this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // Implementation
});
```

### Tool Response Format
```typescript
// ✅ Structured tool responses
return {
  content: [
    {
      type: 'text',
      text: JSON.stringify({
        problems: data,
        count: data.length,
        timestamp: new Date().toISOString()
      }, null, 2)
    }
  ]
};
```

## 📝 Documentation Requirements

### CHANGELOG.md Format
```markdown
## [X.Y.Z](comparison-url) (YYYY-MM-DD)

### Fixed/Added/Changed/Removed

- **🚨 CRITICAL**: Brief description
  - Detailed explanation
  - Solution implemented
  - Impact assessment

### Technical Details

- **Root Cause**: Why it happened
- **Solution**: How it was fixed
- **Validation**: Testing performed
```

### Commit Message Format
```bash
# Use conventional commits
fix: resolve missing lodash dependency preventing activation
feat: add new MCP tool for workspace summaries
docs: update API documentation
test: add integration tests for MCP server
```

## 🧪 Testing Requirements

### Test Categories (Maintain 100% Pass Rate)
- **Unit Tests**: Individual functions and classes
- **Integration Tests**: Component interactions
- **E2E Tests**: Full extension workflow
- **Performance Tests**: Large workspace handling

### Mock Pattern for VS Code API
```typescript
// ✅ Always use dependency injection for VS Code API
const mockVscode = {
  languages: {
    onDidChangeDiagnostics: jest.fn(),
    getDiagnostics: jest.fn()
  },
  workspace: {
    getWorkspaceFolder: jest.fn()
  }
} as any as IVsCodeApi;
```

## 🚀 Performance Standards

### Memory Management
- Always dispose of event listeners
- Clear Maps and Sets when no longer needed
- Use WeakMap for object associations when possible
- Monitor memory usage in large workspaces

### Event Handling
```typescript
// ✅ Always debounce high-frequency events
private createDebouncedHandler() {
  return debounce((event: DiagnosticChangeEvent) => {
    this.processDiagnosticChangeEvent(event);
  }, 300); // 300ms debounce
}
```

### Performance Targets
- Extension activation: < 2 seconds
- Diagnostic processing: < 500ms
- MCP tool response: < 100ms
- Package size: < 250KB
- Memory usage: < 50MB baseline

## 🛡️ Security & Best Practices

### Input Validation
```typescript
// ✅ Always use Zod for runtime validation
const ProblemItemSchema = z.object({
  filePath: z.string(),
  severity: z.enum(['Error', 'Warning', 'Information', 'Hint']),
  message: z.string()
});

export function validateProblemItem(data: unknown): ProblemItem {
  return ProblemItemSchema.parse(data);
}
```

### Sensitive Information
- Never log file contents or user data
- Sanitize file paths in error messages
- Use relative paths when possible

## 📦 Packaging & Deployment

### .vscodeignore Critical Files
```bash
# CRITICAL: Understand what gets excluded
node_modules/          # This excludes ALL dependencies!
src/**                # Source files (use compiled /out)
**/*.ts               # TypeScript files
**/*.map              # Source maps
.vscode-test/         # Test artifacts
```

### Pre-Release Checklist
```bash
# ✅ Required before ANY release
- [ ] All tests passing (npm test)
- [ ] Linting clean (npm run lint)
- [ ] Successful compilation (npm run compile:prod)
- [ ] Successful packaging (npm run package)
- [ ] Manual installation test of .vsix file
- [ ] Version number updated in package.json
- [ ] CHANGELOG.md updated with changes
- [ ] No console.log statements in production code
```

## 🎯 Debugging Strategies

### Extension Development Host vs Packaged Extension
```typescript
// Different behaviors to watch for:
// 1. Extension Development Host (F5): Uses node_modules directly
// 2. Packaged Extension (.vsix): Uses bundled files only

// Always test BOTH environments for dependency issues
```

### Primary Debugging Tools
1. **Extension Host Output**: Primary log source for runtime errors
2. **Developer Tools**: For webview debugging
3. **VS Code Extension Host Process**: For performance monitoring
4. **Console Ninja**: For real-time debugging with MCP integration

### Common Issue Patterns
```typescript
// Pattern 1: Missing Dependencies
// Symptom: "Cannot find module 'X'" in packaged extension
// Solution: Remove dependency or bundle correctly

// Pattern 2: VS Code API Errors
// Symptom: "Cannot read properties of undefined"
// Solution: Check API compatibility and error handling

// Pattern 3: MCP Connection Issues
// Symptom: Tools not responding
// Solution: Verify schema-based request handlers
```

## 🔄 Development Workflow

### Feature Development
```bash
# 1. Create feature branch
git checkout -b feature/feature-name

# 2. TDD Development
npm run test:watch  # Keep tests running
# Write failing test → Implement feature → Refactor

# 3. Quality Gates
npm run ci:check    # Full validation
npm run package     # Packaging test

# 4. Documentation
# Update CHANGELOG.md, README.md if needed
```

### Bug Fix Workflow
```bash
# 1. Investigate (see Bug Investigation Checklist above)
# 2. Create hotfix branch
git checkout -b hotfix/critical-issue-name

# 3. Implement minimal fix
# 4. Full testing protocol
npm run ci:check && npm run package

# 5. Version bump
npm version patch   # For bug fixes

# 6. Deploy ASAP for critical issues
```

## 🎨 UI/UX Standards

### Command Palette Integration
```typescript
// ✅ Descriptive command names
"mcpDiagnostics.showStatus": "MCP Diagnostics: Show Status"
"mcpDiagnostics.restart": "MCP Diagnostics: Restart Server"
```

### Status Bar Integration
```typescript
// ✅ Informative status display
statusBarItem.text = `$(error) ${errorCount} $(warning) ${warningCount}`;
statusBarItem.tooltip = 'Click to show MCP Diagnostics status';
```

### Webview Best Practices
```typescript
// ✅ Use VS Code theming
const webviewContent = `
  <style>
    body {
      color: var(--vscode-foreground);
      background: var(--vscode-editor-background);
    }
  </style>
`;
```

## 🔍 Code Review Checklist

Before any code change, verify:
- [ ] No new external dependencies without justification
- [ ] All tests passing
- [ ] Proper error handling implemented
- [ ] VS Code API used correctly (no global calls)
- [ ] MCP handlers use schema-based pattern
- [ ] Memory leaks prevented (proper disposal)
- [ ] Performance impact considered
- [ ] Documentation updated
- [ ] Version number appropriate for change scope

## 📚 Reference Architecture

```
src/
├── extension.ts              # Main activation/deactivation
├── commands/                 # VS Code command implementations
├── core/                     # Business logic (VS Code independent)
│   ├── diagnostics/         # DiagnosticsWatcher, converters
│   └── models/              # Data models and validation
├── infrastructure/           # External system adapters
│   ├── mcp/                 # MCP server implementation
│   └── vscode/              # VS Code API wrappers
├── shared/                   # Common types and utilities
└── test/                     # Test files mirroring src structure
```

## 🎖️ Success Metrics

Maintain these standards:
- **Test Coverage**: 100% pass rate (334+ tests)
- **Build Success**: 100% successful packaging
- **Activation Rate**: >99% successful extension activation
- **Performance**: All timing targets met
- **User Satisfaction**: Clear documentation, reliable functionality

---

**Remember**: Every change should be approached with the same rigor whether it's a critical bug fix or a new feature. The lodash dependency issue taught us that even "simple" dependencies can cause significant deployment problems.

**Key Principle**: Prefer simplicity and native implementations over external dependencies. When in doubt, implement it yourself with proper TypeScript typing and comprehensive tests.

**Release Management**: Always follow the complete 5-phase release workflow to ensure consistent, high-quality releases with proper documentation and validation.
