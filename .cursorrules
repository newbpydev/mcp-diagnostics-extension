# VS Code MCP Diagnostics Extension - Cursor Rules

## 🎯 Project Overview
You are working on the **MCP Diagnostics Extension** for VS Code that monitors diagnostic information (errors, warnings) from the Problems panel and exposes them via Model Context Protocol (MCP) for AI agent consumption.

## 🚨 Critical Workflow Requirements

### 1. Dependency Management (CRITICAL)
```typescript
// ❌ NEVER add external dependencies without careful consideration
// ✅ ALWAYS prefer native implementations

// Example: Use custom debounce instead of lodash
function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(
  func: F,
  wait: number
): (...args: Parameters<F>) => void {
  let timeout: NodeJS.Timeout | undefined;
  return (...args: Parameters<F>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = undefined;
      func(...args);
    }, wait);
  };
}
```

**Why**: External dependencies can cause packaging issues due to `.vscodeignore` excluding `node_modules/`

### 2. Mandatory Testing Protocol
```bash
# BEFORE every commit/change, run:
npm run lint           # Must pass with 0 errors
npm run compile        # Must compile successfully
npm test              # All 322+ tests must pass
npm run package       # Must package without errors
```

### 3. Bug Investigation Checklist
When investigating issues, ALWAYS:
1. ✅ Check Extension Host Output logs first
2. ✅ Test in both Extension Development Host (F5) AND packaged installation
3. ✅ Compare behavior between VS Code and Cursor
4. ✅ Document exact error messages and stack traces
5. ✅ Identify environment differences

### 4. Version Management
```json
// Semantic Versioning Rules
{
  "PATCH": "Bug fixes (1.2.0 → 1.2.1)",
  "MINOR": "New features (1.2.1 → 1.3.0)",
  "MAJOR": "Breaking changes (1.3.0 → 2.0.0)"
}
```

## 📋 Code Quality Standards

### TypeScript Configuration
- Use strict TypeScript settings
- No `any` types allowed (use `unknown` if needed)
- Proper JSDoc documentation for all public APIs
- Type-safe event handling

### Error Handling Pattern
```typescript
// ✅ Always use this pattern for external API calls
try {
  const result = await externalApiCall();
  return result;
} catch (error) {
  console.error('Specific operation failed:', error);
  // Graceful degradation or re-throw with context
  throw new Error(`Failed to perform operation: ${error.message}`);
}
```

### VS Code API Best Practices
```typescript
// ✅ Dependency injection for testability
export class DiagnosticsWatcher {
  constructor(private vscodeApi: IVsCodeApi) {}
}

// ✅ Proper disposal management
export function activate(context: vscode.ExtensionContext) {
  const watcher = new DiagnosticsWatcher(vscode);
  context.subscriptions.push(watcher);
}

// ❌ Never call global getDiagnostics() without URI
// ✅ Always use URI-specific calls
event.uris.forEach(uri => {
  const diagnostics = vscode.languages.getDiagnostics(uri);
});
```

## 🔧 MCP Integration Standards

### Request Handler Pattern
```typescript
// ✅ Use schema-based handlers (MCP SDK v1.12.1+)
this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
  // Implementation
});

this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // Implementation
});
```

### Tool Response Format
```typescript
// ✅ Structured tool responses
return {
  content: [
    {
      type: 'text',
      text: JSON.stringify({
        problems: data,
        count: data.length,
        timestamp: new Date().toISOString()
      }, null, 2)
    }
  ]
};
```

## 📝 Documentation Requirements

### CHANGELOG.md Format
```markdown
## [X.Y.Z](comparison-url) (YYYY-MM-DD)

### Fixed/Added/Changed/Removed

- **🚨 CRITICAL**: Brief description
  - Detailed explanation
  - Solution implemented
  - Impact assessment

### Technical Details

- **Root Cause**: Why it happened
- **Solution**: How it was fixed
- **Validation**: Testing performed
```

### Commit Message Format
```bash
# Use conventional commits
fix: resolve missing lodash dependency preventing activation
feat: add new MCP tool for workspace summaries
docs: update API documentation
test: add integration tests for MCP server
```

## 🧪 Testing Requirements

### Test Categories (Maintain 100% Pass Rate)
- **Unit Tests**: Individual functions and classes
- **Integration Tests**: Component interactions
- **E2E Tests**: Full extension workflow
- **Performance Tests**: Large workspace handling

### Mock Pattern for VS Code API
```typescript
// ✅ Always use dependency injection for VS Code API
const mockVscode = {
  languages: {
    onDidChangeDiagnostics: jest.fn(),
    getDiagnostics: jest.fn()
  },
  workspace: {
    getWorkspaceFolder: jest.fn()
  }
} as any as IVsCodeApi;
```

## 🚀 Performance Standards

### Memory Management
- Always dispose of event listeners
- Clear Maps and Sets when no longer needed
- Use WeakMap for object associations when possible
- Monitor memory usage in large workspaces

### Event Handling
```typescript
// ✅ Always debounce high-frequency events
private createDebouncedHandler() {
  return debounce((event: DiagnosticChangeEvent) => {
    this.processDiagnosticChangeEvent(event);
  }, 300); // 300ms debounce
}
```

### Performance Targets
- Extension activation: < 2 seconds
- Diagnostic processing: < 500ms
- MCP tool response: < 100ms
- Package size: < 250KB
- Memory usage: < 50MB baseline

## 🛡️ Security & Best Practices

### Input Validation
```typescript
// ✅ Always use Zod for runtime validation
const ProblemItemSchema = z.object({
  filePath: z.string(),
  severity: z.enum(['Error', 'Warning', 'Information', 'Hint']),
  message: z.string()
});

export function validateProblemItem(data: unknown): ProblemItem {
  return ProblemItemSchema.parse(data);
}
```

### Sensitive Information
- Never log file contents or user data
- Sanitize file paths in error messages
- Use relative paths when possible

## 📦 Packaging & Deployment

### .vscodeignore Critical Files
```bash
# CRITICAL: Understand what gets excluded
node_modules/          # This excludes ALL dependencies!
src/**                # Source files (use compiled /out)
**/*.ts               # TypeScript files
**/*.map              # Source maps
.vscode-test/         # Test artifacts
```

### Pre-Release Checklist
```bash
# ✅ Required before ANY release
- [ ] All tests passing (npm test)
- [ ] Linting clean (npm run lint)
- [ ] Successful compilation (npm run compile:prod)
- [ ] Successful packaging (npm run package)
- [ ] Manual installation test of .vsix file
- [ ] Version number updated in package.json
- [ ] CHANGELOG.md updated with changes
- [ ] No console.log statements in production code
```

## 🎯 Debugging Strategies

### Extension Development Host vs Packaged Extension
```typescript
// Different behaviors to watch for:
// 1. Extension Development Host (F5): Uses node_modules directly
// 2. Packaged Extension (.vsix): Uses bundled files only

// Always test BOTH environments for dependency issues
```

### Primary Debugging Tools
1. **Extension Host Output**: Primary log source for runtime errors
2. **Developer Tools**: For webview debugging
3. **VS Code Extension Host Process**: For performance monitoring
4. **Console Ninja**: For real-time debugging with MCP integration

### Common Issue Patterns
```typescript
// Pattern 1: Missing Dependencies
// Symptom: "Cannot find module 'X'" in packaged extension
// Solution: Remove dependency or bundle correctly

// Pattern 2: VS Code API Errors
// Symptom: "Cannot read properties of undefined"
// Solution: Check API compatibility and error handling

// Pattern 3: MCP Connection Issues
// Symptom: Tools not responding
// Solution: Verify schema-based request handlers
```

## 🔄 Development Workflow

### Feature Development
```bash
# 1. Create feature branch
git checkout -b feature/feature-name

# 2. TDD Development
npm run test:watch  # Keep tests running
# Write failing test → Implement feature → Refactor

# 3. Quality Gates
npm run ci:check    # Full validation
npm run package     # Packaging test

# 4. Documentation
# Update CHANGELOG.md, README.md if needed
```

### Bug Fix Workflow
```bash
# 1. Investigate (see Bug Investigation Checklist above)
# 2. Create hotfix branch
git checkout -b hotfix/critical-issue-name

# 3. Implement minimal fix
# 4. Full testing protocol
npm run ci:check && npm run package

# 5. Version bump
npm version patch   # For bug fixes

# 6. Deploy ASAP for critical issues
```

## 🎨 UI/UX Standards

### Command Palette Integration
```typescript
// ✅ Descriptive command names
"mcpDiagnostics.showStatus": "MCP Diagnostics: Show Status"
"mcpDiagnostics.restart": "MCP Diagnostics: Restart Server"
```

### Status Bar Integration
```typescript
// ✅ Informative status display
statusBarItem.text = `$(error) ${errorCount} $(warning) ${warningCount}`;
statusBarItem.tooltip = 'Click to show MCP Diagnostics status';
```

### Webview Best Practices
```typescript
// ✅ Use VS Code theming
const webviewContent = `
  <style>
    body {
      color: var(--vscode-foreground);
      background: var(--vscode-editor-background);
    }
  </style>
`;
```

## 🔍 Code Review Checklist

Before any code change, verify:
- [ ] No new external dependencies without justification
- [ ] All tests passing
- [ ] Proper error handling implemented
- [ ] VS Code API used correctly (no global calls)
- [ ] MCP handlers use schema-based pattern
- [ ] Memory leaks prevented (proper disposal)
- [ ] Performance impact considered
- [ ] Documentation updated
- [ ] Version number appropriate for change scope

## 📚 Reference Architecture

```
src/
├── extension.ts              # Main activation/deactivation
├── commands/                 # VS Code command implementations
├── core/                     # Business logic (VS Code independent)
│   ├── diagnostics/         # DiagnosticsWatcher, converters
│   └── models/              # Data models and validation
├── infrastructure/           # External system adapters
│   ├── mcp/                 # MCP server implementation
│   └── vscode/              # VS Code API wrappers
├── shared/                   # Common types and utilities
└── test/                     # Test files mirroring src structure
```

## 🎖️ Success Metrics

Maintain these standards:
- **Test Coverage**: 100% pass rate (322+ tests)
- **Build Success**: 100% successful packaging
- **Activation Rate**: >99% successful extension activation
- **Performance**: All timing targets met
- **User Satisfaction**: Clear documentation, reliable functionality

---

**Remember**: Every change should be approached with the same rigor whether it's a critical bug fix or a new feature. The lodash dependency issue taught us that even "simple" dependencies can cause significant deployment problems.

**Key Principle**: Prefer simplicity and native implementations over external dependencies. When in doubt, implement it yourself with proper TypeScript typing and comprehensive tests.
