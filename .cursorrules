# VS Code MCP Diagnostics Extension - Cursor Rules

## üéØ Project Overview
You are working on the **MCP Diagnostics Extension** for VS Code that monitors diagnostic information (errors, warnings) from the Problems panel and exposes them via Model Context Protocol (MCP) for AI agent consumption.

## üö® Critical Workflow Requirements

### 1. Dependency Management (CRITICAL)
```typescript
// ‚ùå NEVER add external dependencies without careful consideration
// ‚úÖ ALWAYS prefer native implementations

// Example: Use custom debounce instead of lodash
function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(
  func: F,
  wait: number
): (...args: Parameters<F>) => void {
  let timeout: NodeJS.Timeout | undefined;
  return (...args: Parameters<F>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = undefined;
      func(...args);
    }, wait);
  };
}
```

**Why**: External dependencies can cause packaging issues due to `.vscodeignore` excluding `node_modules/`

### 2. Mandatory Testing Protocol
```bash
# BEFORE every commit/change, run:
npm run lint           # Must pass with 0 errors
npm run compile        # Must compile successfully
npm test              # All 322+ tests must pass
npm run package       # Must package without errors
```

### 3. Bug Investigation Checklist
When investigating issues, ALWAYS:
1. ‚úÖ Check Extension Host Output logs first
2. ‚úÖ Test in both Extension Development Host (F5) AND packaged installation
3. ‚úÖ Compare behavior between VS Code and Cursor
4. ‚úÖ Document exact error messages and stack traces
5. ‚úÖ Identify environment differences

### 4. Version Management
```json
// Semantic Versioning Rules
{
  "PATCH": "Bug fixes (1.2.0 ‚Üí 1.2.1)",
  "MINOR": "New features (1.2.1 ‚Üí 1.3.0)",
  "MAJOR": "Breaking changes (1.3.0 ‚Üí 2.0.0)"
}
```

## üìã Code Quality Standards

### TypeScript Configuration
- Use strict TypeScript settings
- No `any` types allowed (use `unknown` if needed)
- Proper JSDoc documentation for all public APIs
- Type-safe event handling

### Error Handling Pattern
```typescript
// ‚úÖ Always use this pattern for external API calls
try {
  const result = await externalApiCall();
  return result;
} catch (error) {
  console.error('Specific operation failed:', error);
  // Graceful degradation or re-throw with context
  throw new Error(`Failed to perform operation: ${error.message}`);
}
```

### VS Code API Best Practices
```typescript
// ‚úÖ Dependency injection for testability
export class DiagnosticsWatcher {
  constructor(private vscodeApi: IVsCodeApi) {}
}

// ‚úÖ Proper disposal management
export function activate(context: vscode.ExtensionContext) {
  const watcher = new DiagnosticsWatcher(vscode);
  context.subscriptions.push(watcher);
}

// ‚ùå Never call global getDiagnostics() without URI
// ‚úÖ Always use URI-specific calls
event.uris.forEach(uri => {
  const diagnostics = vscode.languages.getDiagnostics(uri);
});
```

## üîß MCP Integration Standards

### Request Handler Pattern
```typescript
// ‚úÖ Use schema-based handlers (MCP SDK v1.12.1+)
this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
  // Implementation
});

this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // Implementation
});
```

### Tool Response Format
```typescript
// ‚úÖ Structured tool responses
return {
  content: [
    {
      type: 'text',
      text: JSON.stringify({
        problems: data,
        count: data.length,
        timestamp: new Date().toISOString()
      }, null, 2)
    }
  ]
};
```

## üìù Documentation Requirements

### CHANGELOG.md Format
```markdown
## [X.Y.Z](comparison-url) (YYYY-MM-DD)

### Fixed/Added/Changed/Removed

- **üö® CRITICAL**: Brief description
  - Detailed explanation
  - Solution implemented
  - Impact assessment

### Technical Details

- **Root Cause**: Why it happened
- **Solution**: How it was fixed
- **Validation**: Testing performed
```

### Commit Message Format
```bash
# Use conventional commits
fix: resolve missing lodash dependency preventing activation
feat: add new MCP tool for workspace summaries
docs: update API documentation
test: add integration tests for MCP server
```

## üß™ Testing Requirements

### Test Categories (Maintain 100% Pass Rate)
- **Unit Tests**: Individual functions and classes
- **Integration Tests**: Component interactions
- **E2E Tests**: Full extension workflow
- **Performance Tests**: Large workspace handling

### Mock Pattern for VS Code API
```typescript
// ‚úÖ Always use dependency injection for VS Code API
const mockVscode = {
  languages: {
    onDidChangeDiagnostics: jest.fn(),
    getDiagnostics: jest.fn()
  },
  workspace: {
    getWorkspaceFolder: jest.fn()
  }
} as any as IVsCodeApi;
```

## üöÄ Performance Standards

### Memory Management
- Always dispose of event listeners
- Clear Maps and Sets when no longer needed
- Use WeakMap for object associations when possible
- Monitor memory usage in large workspaces

### Event Handling
```typescript
// ‚úÖ Always debounce high-frequency events
private createDebouncedHandler() {
  return debounce((event: DiagnosticChangeEvent) => {
    this.processDiagnosticChangeEvent(event);
  }, 300); // 300ms debounce
}
```

### Performance Targets
- Extension activation: < 2 seconds
- Diagnostic processing: < 500ms
- MCP tool response: < 100ms
- Package size: < 250KB
- Memory usage: < 50MB baseline

## üõ°Ô∏è Security & Best Practices

### Input Validation
```typescript
// ‚úÖ Always use Zod for runtime validation
const ProblemItemSchema = z.object({
  filePath: z.string(),
  severity: z.enum(['Error', 'Warning', 'Information', 'Hint']),
  message: z.string()
});

export function validateProblemItem(data: unknown): ProblemItem {
  return ProblemItemSchema.parse(data);
}
```

### Sensitive Information
- Never log file contents or user data
- Sanitize file paths in error messages
- Use relative paths when possible

## üì¶ Packaging & Deployment

### .vscodeignore Critical Files
```bash
# CRITICAL: Understand what gets excluded
node_modules/          # This excludes ALL dependencies!
src/**                # Source files (use compiled /out)
**/*.ts               # TypeScript files
**/*.map              # Source maps
.vscode-test/         # Test artifacts
```

### Pre-Release Checklist
```bash
# ‚úÖ Required before ANY release
- [ ] All tests passing (npm test)
- [ ] Linting clean (npm run lint)
- [ ] Successful compilation (npm run compile:prod)
- [ ] Successful packaging (npm run package)
- [ ] Manual installation test of .vsix file
- [ ] Version number updated in package.json
- [ ] CHANGELOG.md updated with changes
- [ ] No console.log statements in production code
```

## üéØ Debugging Strategies

### Extension Development Host vs Packaged Extension
```typescript
// Different behaviors to watch for:
// 1. Extension Development Host (F5): Uses node_modules directly
// 2. Packaged Extension (.vsix): Uses bundled files only

// Always test BOTH environments for dependency issues
```

### Primary Debugging Tools
1. **Extension Host Output**: Primary log source for runtime errors
2. **Developer Tools**: For webview debugging
3. **VS Code Extension Host Process**: For performance monitoring
4. **Console Ninja**: For real-time debugging with MCP integration

### Common Issue Patterns
```typescript
// Pattern 1: Missing Dependencies
// Symptom: "Cannot find module 'X'" in packaged extension
// Solution: Remove dependency or bundle correctly

// Pattern 2: VS Code API Errors
// Symptom: "Cannot read properties of undefined"
// Solution: Check API compatibility and error handling

// Pattern 3: MCP Connection Issues
// Symptom: Tools not responding
// Solution: Verify schema-based request handlers
```

## üîÑ Development Workflow

### Feature Development
```bash
# 1. Create feature branch
git checkout -b feature/feature-name

# 2. TDD Development
npm run test:watch  # Keep tests running
# Write failing test ‚Üí Implement feature ‚Üí Refactor

# 3. Quality Gates
npm run ci:check    # Full validation
npm run package     # Packaging test

# 4. Documentation
# Update CHANGELOG.md, README.md if needed
```

### Bug Fix Workflow
```bash
# 1. Investigate (see Bug Investigation Checklist above)
# 2. Create hotfix branch
git checkout -b hotfix/critical-issue-name

# 3. Implement minimal fix
# 4. Full testing protocol
npm run ci:check && npm run package

# 5. Version bump
npm version patch   # For bug fixes

# 6. Deploy ASAP for critical issues
```

## üé® UI/UX Standards

### Command Palette Integration
```typescript
// ‚úÖ Descriptive command names
"mcpDiagnostics.showStatus": "MCP Diagnostics: Show Status"
"mcpDiagnostics.restart": "MCP Diagnostics: Restart Server"
```

### Status Bar Integration
```typescript
// ‚úÖ Informative status display
statusBarItem.text = `$(error) ${errorCount} $(warning) ${warningCount}`;
statusBarItem.tooltip = 'Click to show MCP Diagnostics status';
```

### Webview Best Practices
```typescript
// ‚úÖ Use VS Code theming
const webviewContent = `
  <style>
    body {
      color: var(--vscode-foreground);
      background: var(--vscode-editor-background);
    }
  </style>
`;
```

## üîç Code Review Checklist

Before any code change, verify:
- [ ] No new external dependencies without justification
- [ ] All tests passing
- [ ] Proper error handling implemented
- [ ] VS Code API used correctly (no global calls)
- [ ] MCP handlers use schema-based pattern
- [ ] Memory leaks prevented (proper disposal)
- [ ] Performance impact considered
- [ ] Documentation updated
- [ ] Version number appropriate for change scope

## üìö Reference Architecture

```
src/
‚îú‚îÄ‚îÄ extension.ts              # Main activation/deactivation
‚îú‚îÄ‚îÄ commands/                 # VS Code command implementations
‚îú‚îÄ‚îÄ core/                     # Business logic (VS Code independent)
‚îÇ   ‚îú‚îÄ‚îÄ diagnostics/         # DiagnosticsWatcher, converters
‚îÇ   ‚îî‚îÄ‚îÄ models/              # Data models and validation
‚îú‚îÄ‚îÄ infrastructure/           # External system adapters
‚îÇ   ‚îú‚îÄ‚îÄ mcp/                 # MCP server implementation
‚îÇ   ‚îî‚îÄ‚îÄ vscode/              # VS Code API wrappers
‚îú‚îÄ‚îÄ shared/                   # Common types and utilities
‚îî‚îÄ‚îÄ test/                     # Test files mirroring src structure
```

## üéñÔ∏è Success Metrics

Maintain these standards:
- **Test Coverage**: 100% pass rate (322+ tests)
- **Build Success**: 100% successful packaging
- **Activation Rate**: >99% successful extension activation
- **Performance**: All timing targets met
- **User Satisfaction**: Clear documentation, reliable functionality

---

**Remember**: Every change should be approached with the same rigor whether it's a critical bug fix or a new feature. The lodash dependency issue taught us that even "simple" dependencies can cause significant deployment problems.

**Key Principle**: Prefer simplicity and native implementations over external dependencies. When in doubt, implement it yourself with proper TypeScript typing and comprehensive tests.
